TEERANK_VERSION = 3
TEERANK_SUBVERSION = 0
DATABASE_VERSION = 6
STABLE_VERSION = 0

# Used to make a direct URL to github
CURRENT_COMMIT = $(shell git rev-parse HEAD)
CURRENT_BRANCH = $(shell git rev-parse --abbrev-ref HEAD)

# Thoses are used later to build the previous teerank version
PREVIOUS_VERSION = $(shell expr $(TEERANK_VERSION) - 1)
PREVIOUS_DATABASE_VERSION = $(shell expr $(DATABASE_VERSION) - 1)

# This can be set to zero in the command line by the user to remove the
# support of old URLs.  By default we support them to make sure we don't
# accidentaly break existing teerank installation.

ROUTE_V2_URLS ?= 1

# We want to be C89 to make sure teerank can be built using almost any
# compilers on almost any machines you can think of.
#
# Also warnings (treated as error) is mandatory to catch a lot of bugs
# and misuse of the C language.

CFLAGS += \
	-std=c89 \
	-Wall -Werror \
	-Icore -Icgi \
	-lm

# Using POSIX 2008 is another safeguard against unwanted lib C
# extensions.  We could use an older POSIX standard but it turns out
# useful functions are only available in POSIX 2008.

CFLAGS += -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=700

# Send every build infos to the C preprocessor so they can be used by
# teerank and scripts.

CFLAGS += \
	-DTEERANK_VERSION=$(TEERANK_VERSION) \
	-DTEERANK_SUBVERSION=$(TEERANK_SUBVERSION) \
	-DDATABASE_VERSION=$(DATABASE_VERSION) \
	-DSTABLE_VERSION=$(STABLE_VERSION) \
	-DCURRENT_COMMIT=\"$(CURRENT_COMMIT)\" \
	-DCURRENT_BRANCH=\"$(CURRENT_BRANCH)\" \
	-DROUTE_V2_URLS=$(ROUTE_V2_URLS)

# Every scripts is prefixed with teerank-
SCRIPTS += upgrade
SCRIPTS += update
SCRIPTS = $(addprefix teerank-,$(patsubst builtin/%.sh,%,$(wildcard builtin/*.sh)))

# Each builtin have one C file with main() function in "builtin/"
BUILTINS_BINS = $(addprefix teerank-,$(patsubst builtin/%.c,%,$(wildcard builtin/*.c)))

# There is only one upgrade binary per release
UPGRADE_BIN = teerank-upgrade-$(PREVIOUS_DATABASE_VERSION)-to-$(DATABASE_VERSION)

BINS = $(UPGRADE_BIN) $(BUILTINS_BINS)
CGI = teerank.cgi

$(shell mkdir -p generated)

# Add debugging symbols and optimizations to check for more warnings
debug: CFLAGS += -O -g
debug: CFLAGS_EXTRA = -O -g
debug: $(BINS) $(SCRIPTS) $(CGI)

# Remove assertions and enable optimizations
release: CFLAGS += -DNDEBUG -O2
release: CFLAGS_EXTRA = -DNDEBUG -O2
release: $(BINS) $(SCRIPTS) $(CGI)

# Object files
core_objs    = $(patsubst %.c,%.o,$(wildcard core/*.c))
cgi_objs     = $(patsubst %.c,%.o,$(wildcard cgi/*.c) $(wildcard cgi/page/*.c))
builtin_objs = $(patsubst %.c,%.o,$(wildcard builtin/*.c))
upgrade_objs = $(patsubst %.c,%.o,$(wildcard upgrade/*.c))

# Header files
core_headers = $(wildcard core/*.h)
cgi_headers  = $(wildcard cgi/*.h)

# Header files dependencies
$(core_objs):    $(core_headers)
$(builtin_objs): $(core_headers)
$(cgi_objs):     $(core_headers) $(cgi_headers)
$(upgrade_objs): $(core_headers)

# Builtin bins

$(BUILTINS_BINS): teerank-% : builtin/%.o
$(BUILTINS_BINS): $(core_objs)
	$(CC) -o $@ $(CFLAGS) $^

# Script needs to handle configuration variables as well.  The
# necessary code to handle this is generated by a program.  The
# following rule define how to build this program...

build/generate-default-config: build/generate-default-config.o $(core_objs)
	$(CC) -o $@ $(CFLAGS) $^

# This generate a header prepended to every scripts.  This header set
# default values for configuration variables as well as adding the
# current working directory to the PATH.  This is done so that scripts
# will use binaries in the same directory in priority.
#
# Hence doing ./teerank-update for instance will have the desired, as
# it wont use system wide installed binaries (if any).  And doing
# teerank-update in the same directory will use system wide installed
# binaries, as expected too.

generated/script-header.inc.sh: build/generate-default-config
	@echo "#!/bin/sh" >$@
	@echo 'PATH="$$(dirname $$BASH_SOURCE):$$PATH"' >>$@
	./$< >>$@

$(BUILTINS_SCRIPTS): teerank-%: builtin/%.sh

$(SCRIPTS): generated/script-header.inc.sh
	cat $^ >$@ && chmod +x $@

#
# CGI
#

$(CGI): $(core_objs) $(cgi_objs)
	$(CC) -o $@ $(CFLAGS) $^

# The following rules describe how to build a static library for the
# current version.  While it isn't used anywhere, it will be used by the
# *next* teerank version to build an upgrade script.

LIB = libteerank$(DATABASE_VERSION).a
$(LIB): $(core_objs)
	ar rcs $@ $^
	./build/prefix-static-library.sh $@ teerank$(DATABASE_VERSION)_

# The upgrade binary need in order to be built a static library of the
# *previous* teerank version.  In order to get it, we will extract the
# previous teerank version from the git historic.  Built it, and
# finally, make sure exported symbols in core header files are prefixed
# to avoid name clashes with our current code.

PREVIOUS_LIB = libteerank$(PREVIOUS_DATABASE_VERSION).a
PREVIOUS_BRANCH = teerank-$(PREVIOUS_VERSION).y

# Header files needs to be prefixed
build/prefix-header: build/prefix-header.o
	$(CC) -o $@ $(CFLAGS) $^

$(PREVIOUS_LIB): dest = .build/teerank$(PREVIOUS_DATABASE_VERSION)
$(PREVIOUS_LIB): .git/refs/heads/$(PREVIOUS_BRANCH) build/prefix-header
	mkdir -p $(dest)
	git archive $(PREVIOUS_BRANCH) | tar x -C $(dest)
	CFLAGS="$(CFLAGS_EXTRA)" $(MAKE) -C $(dest) $(PREVIOUS_LIB)
	cp $(dest)/$(PREVIOUS_LIB) .

	# Prefix every header file in core
	for i in $(dest)/core/*.h; do \
		./build/prefix-header teerank$(PREVIOUS_DATABASE_VERSION)_ <"$$i" >"$$i".tmp; \
		mv "$$i".tmp "$$i"; \
	done

# Upgrade binary just need the static library of the previous teerank
# version as well as a path the the previous header files as well.

upgrade_objs = $(patsubst %.c,%.o,$(wildcard upgrade/*.c))
$(upgrade_objs): CFLAGS += -I.build
$(upgrade_objs): $(PREVIOUS_LIB)
$(UPGRADE_BIN): $(core_objs) $(upgrade_objs) $(PREVIOUS_LIB)
	$(CC) -o $@ $(CFLAGS) -I.build $^

#
# Clean
#

clean:
	rm -f core/*.o builtin/*.o cgi/*.o cgi/page/*.o build/*.o
	rm -f $(BINS) $(SCRIPTS) $(CGI) $(LIB)
	rm -f $(LIB) $(PREVIOUS_LIB)
	rm -f generated/script-header.inc.sh build/generate-default-config build/prefix-header
	rm -rf generated/ .build/

#
# Install
#

install: TEERANK_ROOT       = $(prefix)/var/lib/teerank
install: TEERANK_DATA_ROOT  = $(prefix)/usr/share/webapps/teerank
install: TEERANK_BIN_ROOT   = $(prefix)/usr/bin
install:
	mkdir -p $(TEERANK_ROOT)
	mkdir -p $(TEERANK_DATA_ROOT)
	mkdir -p $(TEERANK_BIN_ROOT)

	cp $(BINS) $(SCRIPTS) $(TEERANK_BIN_ROOT)
	cp -r $(CGI) assets/* $(TEERANK_DATA_ROOT)

.PHONY: all debug release lib clean install
