#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <libgen.h>

#include "io.h"
#include "config.h"
#include "route.h"

static char *reason_phrase(int code)
{
	switch (code) {
	case 200: return "OK";
	case 400: return "Bad Request";
	case 404: return "Not Found";
	case 414: return "Request-URI Too Long";
	case 500: return "Internal Server Error";
	default:  return "";
	}
}

static void print_error(int code)
{
	printf("Content-type: text/html\n");
	printf("Status: %d %s\n\n", code, reason_phrase(code));
	printf("<h1>%d %s</h1>\n", code, reason_phrase(code));
}

void error(int code, char *fmt, ...)
{
	va_list ap;

	print_error(code);
	if (fmt) {
		va_start(ap, fmt);
		vfprintf(stderr, fmt, ap);
		va_end(ap);
	} else {
		fprintf(stderr, "%d %s\n", code, reason_phrase(code));
	}

	exit(EXIT_FAILURE);
}

/* Return true if a is more recent than b */
static int is_more_recent(struct stat *a, struct stat *b)
{
	return a->st_mtim.tv_sec > b->st_mtim.tv_sec;
}

static int is_up_to_date(struct route *route)
{
	struct stat s, tmp;

	assert(route != NULL);

	/* First, if the route is not in cache, it need to be generated */
	if (!route->cache || stat(route->cache, &s) == -1)
		return 0;

	/* Regenerate if the source route is more recent */
	if (route->source) {
		if (stat(route->source, &tmp) == -1)
			return 0;
		if (is_more_recent(&tmp, &s))
			return 0;
	}

	return 1;
}

static int generate(struct route *route)
{
	int dest[2], src = -1, err[2];
	char tmpname[PATH_MAX];

	assert(route != NULL);
	assert(route->args != NULL);
	assert(route->args[0] != NULL);

	/*
	 * Files are generated by calling a program that write on stdout the
	 * content of the page.
	 *
	 * The program have to write on stdout, and therefor we need to
	 * redirect stdout.  We redirect it to a temporary file created on
	 * purpose, and then use rename() to move the temporary file to his
	 * proper location in cache.  This is done to avoid any race conditions
	 * when two instances of this CGI generate the same file in cache.
	 *
	 * The program may fail and in this case we return an error 500 and
	 * dump the content of stderr.  For that purpose we need to redirect
	 * stderr to a pipe so that the parent can retrieve errors, if any.
	 *
	 * Eventually, the child may need stdin feeded with some data.
	 */

	if (is_up_to_date(route)) {
		verbose("'%s' already cached and up-to-date\n", route->cache);
		if ((dest[0] = open(route->cache, O_RDONLY)) == -1)
			error(500, "open(%s): %s\n", route->cache, strerror(errno));
		return dest[0];
	}

	verbose("Generating '%s' with '%s'\n", route->cache, route->args[0]);

	/*
	 * Open src before fork() because if the file doesn't exist, then we
	 * raise a 404, and if it does but cannot be opened, we raise a 500.
	 */
	if (route->source) {
		static char source[PATH_MAX];

		if (snprintf(source, PATH_MAX, "%s/%s", config.root, route->source) >= PATH_MAX)
			error(414, NULL);

		if ((src = open(source, O_RDONLY)) == -1) {
			if (errno == ENOENT)
				error(404, NULL);
			else
				error(500, "%s: %s\n", source, strerror(errno));
		}
	}

	if (route->cache) {
		/*
		 * If the file needs to be cached, redirect stdout to a
		 * temporary file and then rename() it later on to the
		 * real destination in cache.
		 */
		if (snprintf(tmpname, PATH_MAX, "%s/tmp-teerank-XXXXXX", config.tmp_root) >= PATH_MAX)
			error(500, "Pathname for temporary file is too long (>= %d)\n", PATH_MAX);
		if ((dest[0] = dest[1] = mkstemp(tmpname)) == -1)
			error(500, "mkstemp(): %s\n", strerror(errno));
	} else {
		/*
		 * If the file do not need to be cached, just create a pipe
		 * to redirect stdout in.
		 */
		if (pipe(dest) == -1)
			error(500, "pipe(dest): %s\n", strerror(errno));
	}

	if (pipe(err) == -1)
		error(500, "pipe(err): %s\n", strerror(errno));

	/*
	 * Parent process wait for it's child to terminate and dump the
	 * content of the pipe if child's exit status is different than 0.
	 */
	if (fork() > 0) {
		int c;
		FILE *pipefile;

		close(err[1]);

		if (route->source)
			close(src);
		if (!route->cache)
			close(dest[1]);

		wait(&c);
		if (WIFEXITED(c) && WEXITSTATUS(c) == EXIT_SUCCESS) {
			if (route->cache) {
				if (rename(tmpname, route->cache) == -1)
					error(500, "rename(%s, %s): %s\n",
					      tmpname, route->cache, strerror(errno));
				if (lseek(dest[0], 0, SEEK_SET) == -1)
					error(500, "lseek(%s): %s\n", tmpname, strerror(errno));
			}
			return dest[0];
		}

		/* Report error */
		print_error(500);
		fprintf(stderr, "%s: ", route->args[0]);
		pipefile = fdopen(err[0], "r");
		while ((c = fgetc(pipefile)) != EOF)
			fputc(c, stderr);
		fclose(pipefile);

		exit(EXIT_FAILURE);
	}

	/* Redirect stderr to the write side of the pipe */
	dup2(err[1], STDERR_FILENO);
	close(err[0]);

	/* Redirect stdin */
	if (route->source) {
		dup2(src, STDIN_FILENO);
		close(src);
	}

	/* Redirect stdout */
	dup2(dest[1], STDOUT_FILENO);
	close(dest[1]);

	if (!route->cache)
		close(dest[0]);

	/* Eventually, run the program */
	execvp(route->args[0], route->args);
	fprintf(stderr, "execvp(%s): %s\n", route->args[0], strerror(errno));
	exit(EXIT_FAILURE);
}

static void print(int fd)
{
	FILE *file;
	int c;

	assert(fd != -1);

	if (!(file = fdopen(fd, "r")))
		error(500, "fdopen(): %s\n", strerror(errno));
	printf("Content-Type: text/html\n\n");
	while ((c = fgetc(file)) != EOF)
		putchar(c);
	fclose(file);
}

static void create_directory(char *fmt, ...)
{
	va_list ap;
	char path[PATH_MAX];
	int ret;

	va_start(ap, fmt);
	vsprintf(path, fmt, ap);
	va_end(ap);

	if ((ret = mkdir(path, 0777)) == -1)
		if (errno != EEXIST)
			error(500, "%s: %s\n", path, strerror(errno));
}

static void init_cache(void)
{
	create_directory("%s", config.cache_root);
	create_directory("%s/pages", config.cache_root);
	create_directory("%s/clans", config.cache_root);
}

static char *get_path(void)
{
	static char *tmp, path[PATH_MAX];

	if (!(tmp = getenv("PATH_INFO")) && !(tmp = getenv("DOCUMENT_URI")))
		error(500, "PATH_INFO or DOCUMENT_URI not set\n");

	/* Env vars cannot be modified so we have to copy it */
	if (*stpncpy(path, tmp, PATH_MAX) != '\0')
		error(414, NULL);

	return path;
}

static char *get_query(void)
{
	static char *tmp, query[PATH_MAX] = "";

	if (!(tmp = getenv("QUERY_STRING")))
		return query;

	/* Env vars cannot be modified so we have to copy it */
	if (*stpncpy(query, tmp, PATH_MAX) != '\0')
		error(414, NULL);

	return query;
}

int main(int argc, char **argv)
{
	load_config();
	init_cache();

	if (argc != 1) {
		fprintf(stderr, "usage: %s\n", argv[0]);
		fprintf(stderr, "This program expect $PATH_INFO or $DOCUMENT_URI to be set, and optionally $QUERY_STRING.\n");
		error(500, NULL);
	}

	print(generate(do_route(get_path(), get_query())));

	return EXIT_SUCCESS;
}
